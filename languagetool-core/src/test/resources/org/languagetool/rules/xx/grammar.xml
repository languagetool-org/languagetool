<?xml-stylesheet type="text/xsl" href="../print.xsl"
        title="Pretty print" ?>
<?xml-stylesheet type="text/css" href="../rules.css"
        title="Easy editing stylesheet" ?>
<!--
A demo rule file for LanguageTool
Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
-->
<rules lang="xx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../main/resources/org/languagetool/rules/rules.xsd">

    <!-- tests for phrase syntax -->
    <unification feature="case_sensitivity">
        <equivalence type="startupper">
            <token regexp="yes">\p{Lu}\p{Ll}+</token>
        </equivalence>
        <equivalence type="lowercase">
            <token regexp="yes">\p{Ll}+</token>
        </equivalence>
    </unification>
    <unification feature="gender">
        <equivalence type="masc">
            <token regexp="yes">.*-masc</token>
        </equivalence>
        <equivalence type="fem">
            <token regexp="yes">.*-fem</token>
        </equivalence>
    </unification>
    <unification feature="number">
        <equivalence type="plur">
            <token regexp="yes">.*-plur-.*</token>
        </equivalence>
        <equivalence type="sing">
            <token regexp="yes">.*-sing-.*</token>
        </equivalence>
    </unification>

    <phrases>
        <phrase id="UNIFICATION_PHRASE">
            <unify>
                <feature id="case_sensitivity">
                    <type id="startupper"/>
                </feature>
                <token/>
                <token>York</token>
            </unify>
        </phrase>
        <phrase id="NP">
            <token>trivial</token>
            <token>phrase</token>
            <token>demo</token>
            <token><exception>exception</exception></token>
        </phrase>
        <phrase id="COMPLEX_PHRASE">
            <token>complex</token>
            <includephrases>
                <phraseref idref="NP"/>
            </includephrases>
            <token>another</token>
        </phrase>
        <phrase id="DUMMY_VB1">
            <token regexp="yes">go|goa</token>
        </phrase>
        <phrase id="DUMMY_VB2">
            <token>goes</token>
        </phrase>
        <phrase id="DUMMY_VB3">
            <token>went</token>
        </phrase>
        <phrase id="COMPLEX_MULTIPLE">
            <token>first</token>
            <includephrases>
                <phraseref idref="DUMMY_VB1"/>
                <phraseref idref="DUMMY_VB2"/>
                <phraseref idref="DUMMY_VB3"/>
            </includephrases>
            <token>last</token>
        </phrase>
        <phrase id="SINGLE_TOKEN">
            <token>single</token>
        </phrase>
        <phrase id="TEST_INCLUDE">
            <token>beginning</token>
            <includephrases>
                <phraseref idref="COMPLEX_MULTIPLE"/>
                <phraseref idref="SINGLE_TOKEN"/>
            </includephrases>
            <token>end</token>
        </phrase>
        <phrase id="trivial_include">
            <includephrases>
                <phraseref idref="DUMMY_VB1"/>
            </includephrases>
            <includephrases>
                <phraseref idref="DUMMY_VB2"/>
            </includephrases>
        </phrase>
    </phrases>

    <category id="MISC" name="misc">
        <rule id="REGEX_DEMO_RULE" name="Find 'foo bar'">
            <regexp>(fo[ou]) bar</regexp>
            <message>Did you mean <suggestion>\1 baz</suggestion>?</message>
            <example>This is <marker>fuu bah</marker>.</example>
            <example correction="foo baz">This is <marker>foo bar</marker>.</example>
            <example correction="fou baz">This is <marker>fou bar</marker>.</example>
        </rule>
        <rule id="REGEX_DEMO_RULE_UMLAUTS" name="German umlaut case insensitivity">
            <regexp>über all</regexp>
            <message>foo message</message>
            <example correction=""><marker>über all</marker></example>
            <example correction=""><marker>Über all</marker></example>
            <example correction=""><marker>ÜBER all</marker></example>
        </rule>
        <rule id="REGEX_DEMO_PARTIAL_MARK" name="Regexp match with 'mark' attribute">
            <regexp mark="2">(fo[ou]) (bar)</regexp>
            <message>Did you mean <suggestion>baz</suggestion>?</message>
            <example>This is fuu <marker>bah</marker>.</example>
            <example correction="baz">This is foo <marker>bar</marker>.</example>
            <example correction="baz">This is fou <marker>bar</marker>.</example>
        </rule>
        <rule id="REGEX_PATTERN_RULE_DEMO_MARK_0" name="see: RegexpPatternRuleTest">
            <regexp>(fo.) (bar)</regexp>
            <message>msg: <suggestion>a suggestion \1</suggestion></message>
            <suggestion>another suggestion \2</suggestion>
            <example correction="a suggestion fou|another suggestion bar"><marker>fou bar</marker></example>
        </rule>
        <rule id="REGEX_PATTERN_RULE_DEMO_MARK_1" name="see: RegexpPatternRuleTest">
            <regexp mark="1">(fo.) (bar)</regexp>
            <message>msg: <suggestion>a suggestion \1 !</suggestion></message>
            <suggestion>another suggestion \2 !</suggestion>
            <example correction="a suggestion fou !|another suggestion bar !">This is <marker>fou</marker> bar</example>
        </rule>
        <rule id="DEMO_RULE" name="Find 'foo bar'">
            <!-- a trivial demo rule that matches "foo" followed by "bar" -->
            <pattern case_sensitive="no">
                <token>foo</token>
                <token>bar</token>
            </pattern>
            <message>Did you mean <suggestion><match no="1"/> fuu bah</suggestion>?</message>
            <url>http://fake-server.org/foo-bar-error-explained</url>
            <example>This is <marker>fuu bah</marker>.</example>
            <example correction="foo fuu bah">This is <marker>foo bar</marker>.</example>
        </rule>
        <rule id="DEMO_RULE_OFF" name="off by default" default="off">
            <pattern>
                <token>foosomething</token>
            </pattern>
            <message>This rule is off by default</message>
            <example>This is <marker>foo different</marker>.</example>
            <example correction="">This is <marker>foosomething</marker>.</example>
        </rule>
        <rule id="DEMO_RULE_ANTIPATTERN" name="Find 'foo bar' but not 'not this'">
            <antipattern>
                <token>bar</token>
                <token>,</token>
            </antipattern>
            <pattern>
                <token>foo</token>
                <token>bar</token>
            </pattern>
            <message>Did you mean <suggestion>foo</suggestion>?</message>
            <example>This is <marker>fuu bah</marker>.</example>
            <example correction="foo">This is <marker>foo bar</marker>.</example>
            <example>This is <marker>foo bar</marker>, but this is not.</example>
        </rule>
        <rulegroup id="GROUP_WITH_URL" name="rule group with url">
            <url>http://fake-server.org/rule-group-url</url>
            <short>short message on rule group</short>
            <rule>
                <pattern>
                    <token>fake1</token>
                </pattern>
                <message>msg1</message>
                <example correction=""><marker>fake1</marker></example>
                <example>fake2</example>
            </rule>
            <rule>
                <pattern>
                    <token>fake1</token>
                </pattern>
                <message>msg2</message>
                <url>http://fake-server.org/rule-group-url-overwrite</url>
                <short>overwriting short message</short>
                <example correction=""><marker>fake1</marker></example>
                <example>fake2</example>
            </rule>
            <rule>
                <pattern>
                    <token>fake1</token>
                </pattern>
                <message>msg3</message>
                <example correction=""><marker>fake1</marker></example>
                <example>fake2</example>
            </rule>
        </rulegroup>
        <rulegroup id="OR_GROUPS" name="OR groups">
            <rule>
                <pattern>
                    <or>
                        <token>a</token>
                        <token>b</token>
                        <token>c</token>
                    </or>
                    <token>d</token>
                </pattern>
                <message>Incorrect expression.</message>
                <example correction=""><marker>a d</marker></example>
                <example correction=""><marker>b d</marker></example>
                <example correction=""><marker>c d</marker></example>
                <example correction="">a <marker>b d</marker></example>
                <example>d a</example>
                <example>c a</example>
                <example>c b</example>
                <example>a b c</example>
            </rule>
            <rule>
                <pattern>
                    <or>
                        <token>a</token>
                        <token>b</token>
                        <token>c</token>
                    </or>
                    <token/>
                    <or>
                        <token>x</token>
                        <token>y</token>
                        <token>z</token>
                    </or>
                </pattern>
                <message>Incorrect expression.</message>
                <example correction=""><marker>b f x</marker></example>
                <example correction=""><marker>a g z</marker></example>
                <example correction=""><marker>b d y</marker></example>
                <example correction="">a <marker>b h z</marker></example>
                <example>d a d</example>
                <example>c a c</example>
                <example>y b y</example>
                <example>z b a</example>
            </rule>
        </rulegroup>
        <rule id="DEMO_CHUNK_RULE" name="Rule with chunk attribute">
            <pattern case_sensitive="no">
                <token>foo</token>
                <token chunk="B-NP-singular"/>
            </pattern>
            <message>Did you mean <suggestion>foo bar</suggestion>?</message>
            <example>This is <marker>foo bar</marker>.</example>
            <example correction="foo bar">This is <marker>foo chunkbar</marker>.</example>
        </rule>
        <rule id="API_OUTPUT_TEST_RULE" name="Find 'foo bar'">
            <pattern case_sensitive="no">
                <token>ach</token>
                <marker>
                    <token>thosnaíos-sa</token>
                </marker>
            </pattern>
            <message>Did you mean <suggestion>fuu bah</suggestion>?</message>
            <example>This is ach <marker>fuu bah</marker>.</example>
            <example correction="fuu bah">This is ach <marker>thosnaíos-sa</marker>.</example>
        </rule>
        <rule id="NEGATION_TOKEN" name="test negation">
            <pattern>
                <token>small</token>
                <marker>
                    <token negate="yes">test</token>
                </marker>
            </pattern>
            <message>test</message>
            <example>a small <marker>test</marker></example>
            <example correction="">a small <marker>toast</marker></example>
        </rule>
        <rulegroup id="REGEXP_SUGGESTIONS_INSIDE_OUTSIDE_MESSAGE" name="regexp suggestions when inside and outside the message testing">
            <rule id="REGEXP_MATCH_SUGGESTIONS_INSIDE" name="xnel vola -> vo nel la">
                <regexp>[Xx][Nn](' el|el|i l') ((ri?|)vo?(la|ci|cial|chal))(-t i|-t ele|) nén</regexp>
                <message>Test 01: <suggestion>vo <match no="0"
                                                        regexp_match="[Xx].* (ri?|)vo?(la|ci|cial|chal)(-t i|-t ele|) nén"
                                                        regexp_replace="nel $1$2$3 nén"/></suggestion></message>
                <example correction="vo nel la-t i nén"><marker>xnel vola-t i nén</marker> co.</example>
            </rule>
            <rule id="REGEXP_MATCH_SUGGESTIONS_OUTSIDE" name="xnel vola -> vo nel la">
                <regexp>[Xx][Nn](' el|el|i l') ((ri?|)vo?(la|ci|cial|chal))(-t i|-t ele|) nén</regexp>

                <message>Test 02: </message>
                <suggestion>vo <match no="0"
                                      regexp_match="[Xx].* (ri?|)vo?(la|ci|cial|chal)(-t i|-t ele|) nén"
                                      regexp_replace="nel $1$2$3 nén"/></suggestion>
                <example correction="vo nel la-t i nén"><marker>xnel vola-t i nén</marker> co.</example>
            </rule>
            <rule id="PATTERN_REGEXP_MATCH_SUGGESTIONS_INSIDE" name="znel vola -> vo nel la">
                <pattern>
                    <token>znel</token>
                    <token regexp="yes">(ri?|)vo?(la|ci|cial|chal)</token>
                </pattern>
                <message>Test 03: <suggestion>vo <match no="1" case_conversion="startlower"
                                                        regexp_match="[zZ](nel)"
                                                        regexp_replace="$1"></match> <match no="2"
                                                                                            regexp_match="(ri?|)vo?(la|ci|cial|chal)"
                                                                                            regexp_replace="$1$2"></match></suggestion>?</message>
                <example correction="Vo nel la"><marker>Znel vola</marker> nén.</example>
            </rule>
            <rule id="PATTERN_REGEXP_MATCH_SUGGESTIONS_OUTSIDE" name="znel vola -> vo nel la">
                <pattern>
                    <token>znel</token>
                    <token regexp="yes">(ri?|)vo?(la|ci|cial|chal)</token>
                </pattern>
                <message>Test 03: </message>
                <suggestion>vo <match no="1" case_conversion="startlower"
                                      regexp_match="[zZ](nel)"
                                      regexp_replace="$1"></match> <match no="2"
                                                                          regexp_match="(ri?|)vo?(la|ci|cial|chal)"
                                                                          regexp_replace="$1$2"></match></suggestion>
                <example correction="Vo nel la"><marker>Znel vola</marker> nén.</example>
            </rule>
            <rule id="PATTERN_REGEXP_EXAMPLE_6234" name="62-Bit (64-Bit) etc.">
                <regexp>(62|34)-bit</regexp>
                <message>Meinten Sie <suggestion><match no="0" regexp_match="62|34" regexp_replace="32"/></suggestion> oder <suggestion><match no="0" regexp_match="62|34" regexp_replace="64"/></suggestion>?</message>
                <example correction="32-Bit|64-Bit">Du solltest die <marker>62-Bit</marker>-Version installieren</example>
            </rule>
            <rule id="PATTERN_REGEXP_EXAMPLE_MULTIPLICATION">
                <regexp>([a-z]|[\d\.,⁻¹²³⁴⁵⁶⁷⁸⁹⁰]+?[a-z]{0,1})\*([a-z]|[\d\.,⁻¹²³⁴⁵⁶⁷⁸⁹⁰]+?[a-z]{0,1})</regexp>
                <message>Prefira o símbolo de multiplicación.</message>
                <suggestion><match no="1" case_conversion="allupper"/>×\2</suggestion>
                <suggestion>\1·\2</suggestion>
                <example correction="5×x|5·x">a=<marker>5*x</marker>+7</example>
                <example correction="5x×5|5x·5">a=<marker>5x*5</marker>+7</example>
                <example correction="a×b|a·b"><marker>a*b</marker></example>
                <example>a=2·x²+5</example>
                <example>4,5×2,5=11,25</example>
            </rule>
            <rule id="PATTERN_REGEXP_EXAMPLE_OLDSTYLE_REFERENCE_ON_START" name="'gehießen (geheißen)'">
                <regexp>(gehießen)</regexp>
                <message>\1 ist umgangssprachlich.</message>
                <suggestion>geheißen</suggestion>
                <example correction="geheißen">Sie hat früher Müller <marker>gehießen</marker>.</example>
            </rule>
        </rulegroup>
    </category>

    <category id="OTHER" name="otherCategory" type="addition">
        <rule id="TEST_GO" name="another test of phrases">
            <pattern>
                <token>foo</token>
                <phraseref idref="DUMMY_VB1"/>
            </pattern>
            <message>Error!</message>
            <example>foo bar</example>
            <example correction=""><marker>foo go</marker></example>
            <example correction=""><marker>foo go</marker> bar</example>
            <example correction=""><marker>foo goa</marker> bar</example>
        </rule>
        <rule id="TEST_PHRASES1" name="test phrases mechanism" type="uncategorized">
            <pattern>
                <phraseref idref="COMPLEX_MULTIPLE"/>
                <token>there</token>
            </pattern>
            <message>This is the matched text: <match no="1"/><match no="2"/></message>
            <example>go here</example>
            <example correction=""><marker>first goes last there</marker>, please!</example>
        </rule>
        <rule id="test_include" name="test two includeblocks" type="characters">
            <pattern>
                <phraseref idref="TEST_INCLUDE"/>
            </pattern>
            <message>Matched: <suggestion>test <match no="1"/>trala</suggestion></message>
            <example>Any string.</example>
            <example correction="test beginning first go last endtrala">Some words, <marker>beginning first go last end</marker></example>
        </rule>
        <rule id="test_include_and_skip" name="test two includeblocks">
            <pattern>
                <token skip="2">any</token>
                <phraseref idref="TEST_INCLUDE"/>
                <token>word</token>
            </pattern>
            <message>Matched: <suggestion><match no="1"/> test</suggestion></message>
            <example>Any string.</example>
            <example correction="any test">Some words, <marker>any word beginning first go last end word</marker></example>
        </rule>
        <!--  why should this work this way? two phraserefs generate a logical
            disjunction for some obscure reason! -->
        <rule id="test_two_phrases" name="test two phrases">
            <pattern>
                <phraseref idref="COMPLEX_MULTIPLE"/>
                <phraseref idref="SINGLE_TOKEN"/>
            </pattern>
            <message>Matched: <match no="1"/></message>
            <example>Any string.</example>
            <example correction="">First words and <marker>first go last</marker></example>
        </rule>
        <rule id="test_and_operator" name="test logical AND">
            <pattern>
                <marker>
                    <and>
                        <token regexp="yes">A.*</token>
                        <token regexp="yes">[A-Z]B.*</token>
                        <token negate="yes">ABC</token>
                        <token regexp="yes">.*D<exception>ABED</exception></token>
                    </and>
                </marker>
                <token>test</token>
            </pattern>
            <message>Matched: <match no="1"/></message>
            <example>CB test</example>
            <example>ABC test</example>
            <example correction=""><marker>ABCD</marker> test</example>
            <example correction=""><marker>ABEED</marker> test</example>
            <example><marker>ABED</marker> test</example>
        </rule>
        <rule id="test_match_ref" name="testing match element...">
            <pattern>
                <token/>
                <token>by</token>
                <token><match no="0"/></token>
            </pattern>
            <message>Found \1 \2 \3.</message>
            <example correction=""><marker>Step by step</marker>.</example>
            <example>blabla</example>
            <example>Steb by step</example>
        </rule>
        <rule id="test_match_ref_superb" name="testing match element on steroids...">
            <pattern>
                <token/>
                <token>by</token>
                <token><match no="0"/>on</token>
            </pattern>
            <message>Found \1 \2 \3.</message>
            <example><marker>Step by step</marker>.</example>
            <example correction=""><marker>Step by stepon</marker>.</example>
            <example>blabla</example>
            <example>Steb by step</example>
        </rule>
        <rulegroup id="test_matching_tokens" name="test parseInt conversion1">
            <rule>
                <pattern>
                    <token>1</token>
                    <token>2</token>
                    <token>3</token>
                    <token>4</token>
                    <token>5</token>
                    <token/>
                    <token>7</token>
                    <token>8</token>
                    <token/>
                    <token>ten</token>
                </pattern>
                <message>I suggest: <suggestion><match no="10"/> blahblah</suggestion>.</message>
                <example>blah</example>
                <example correction="ten blahblah"><marker>1 2 3 4 5 6 7 8 9 ten</marker>.</example>
            </rule>
            <rule>
                <pattern>
                    <token>1</token>
                    <token>2</token>
                    <token>3</token>
                    <token>4</token>
                    <token>5</token>
                    <token/>
                    <token>7</token>
                    <token>8</token>
                    <token/>
                    <token>ten</token>
                </pattern>
                <message>I suggest: <suggestion>\10 blahblah</suggestion>.</message>
                <example>blah</example>
                <example correction="ten blahblah"><marker>1 2 3 4 5 6 7 8 9 ten</marker>.</example>
            </rule>
            <rule>
                <pattern>
                    <token>one</token>
                    <token>two</token>
                    <token>three</token>
                    <token>four</token>
                    <token>five</token>
                    <token/>
                    <token>seven</token>
                    <token>eight</token>
                    <token/>
                    <token>ten</token>
                    <token>eleven</token>
                    <token>twelve</token>
                    <token>thirteen</token>
                </pattern>
                <message>I suggest: <suggestion>\10 \13 \11 \5</suggestion>.</message>
                <short>Error</short>
                <example>blah</example>
                <example correction="ten thirteen eleven five"><marker>one two three four five six seven eight nine ten eleven twelve thirteen</marker>.</example>
            </rule>
        </rulegroup>
        <rule id="test_match_conv" name="example of case conversion">
            <pattern case_sensitive="yes">
                <token>new-york</token>
                <token>cafe</token>
            </pattern>
            <message>This name should be uppercase: <suggestion>New <match case_conversion="startupper" no="1" regexp_match="[Nn]ew-(.*)" regexp_replace="$1"/> Cafe</suggestion></message>
            <example>New York Cafe</example>
            <example correction="New York Cafe">This is a new coffeshop in the middle of nowhere called <marker>new-york cafe</marker>.</example>
        </rule>
        <rule id="test_unification" name="Test unification of character case">
            <pattern case_sensitive="yes">
                <token>abc</token>
                <marker>
                    <unify> <feature id="case_sensitivity">
                        <type id="startupper"/>
                    </feature>
                        <token/>
                        <token>York</token>
                    </unify>
                </marker>
            </pattern>
            <message>Warning: \1 \2 \3!</message>
            <example correction="">abc <marker>New York</marker></example>
            <example>abc new York</example>
        </rule>
        <rule id="test_unification_negate" name="Test negated unification of character case">
            <pattern case_sensitive="yes">
                <token>abc</token>
                <marker>
                    <unify negate="yes">
                        <feature id="case_sensitivity">
                            <type id="startupper"/>
                        </feature>
                        <token/>
                        <token regexp="yes">[yY]ork</token>
                    </unify>
                </marker>
            </pattern>
            <message>Warning: \1 \2 \3!</message>
            <example correction="">abc <marker>new York</marker></example>
            <example correction="">abc <marker>New york</marker></example>
            <example correction="">abc <marker>new york</marker></example>
            <example>abc New York</example>
        </rule>
        <rule id="test_unification_phrase" name="Test unification of characters' case via phrase">
            <pattern case_sensitive="yes">
                <token>abc</token>
                <marker>
                    <phraseref idref="UNIFICATION_PHRASE"/>
                </marker>
            </pattern>
            <message>Warning: \1 \2 \3!</message>
            <example correction="">abc <marker>New York</marker></example>
            <example>abc new York</example>
        </rule>
        <rule id="test_include_skipped" name="Test inclusion of skipped tokens">
            <pattern>
                <token skip="-1">abc</token>
                <token>end</token>
            </pattern>
            <message>Warning: <suggestion><match no="1" include_skipped="all"/> xyz</suggestion></message>
            <example correction="abc def ghi xyz">This is <marker>abc def ghi end</marker>.</example>
            <example>foobar</example>
        </rule>
        <rule id="test_unification_skipping" name="Test unification and skipping">
            <pattern case_sensitive="yes">
                <token>Test1</token>
                <unify>
                    <feature id="case_sensitivity"/>
                    <token skip="-1"><exception scope="next">Ghj</exception></token>
                    <token regexp="yes">[xX]yz</token>
                </unify>
                <token>end</token>
            </pattern>
            <message>This is not visible anyway<suggestion><match no="2" include_skipped="all"/></suggestion>.</message>
            <example correction="Abc">This is <marker>Test1 Abc Xyz end</marker>.</example>
            <example correction="Abc Def">This is <marker>Test1 Abc Def Xyz end</marker>.</example>
            <!-- skipped elements are NOT unified -->
            <example correction="Abc def">This is <marker>Test1 Abc def Xyz end</marker>.</example>
            <example>This is Test1 abc Cde End.</example>
        </rule>
        <rulegroup id="test_spacebefore" name="Test spacebefore on exceptions">
            <rule>
                <pattern>
                    <token>blah<exception scope="previous" spacebefore="no">'</exception></token>
                    <token>blah</token>
                </pattern>
                <message>This is a dummy message 1.</message>
                <example>Dogs' blah blah</example>
                <example correction="">Dogs <marker>blah blah</marker></example>
            </rule>
            <rule type="duplication">
                <pattern>
                    <token regexp="yes">blah.*<exception spacebefore="no">blah</exception></token>
                    <token>blah</token>
                </pattern>
                <message>This is a dummy message 2.</message>
                <example>Dogs 'blah blah</example>
                <example correction="">Dogs <marker>blah blah</marker></example>
            </rule>
        </rulegroup>
        <rulegroup id="test_unification_with_negation" name="Test unification with negation" type="grammar">
            <rule>
                <pattern>
                    <unify negate="yes">
                        <feature id="gender"/>
                        <feature id="number"/>
                        <token><exception postag="SENT_START"/></token>
                        <token/>
                        <token/>
                    </unify>
                </pattern>
                <message>blabla</message>
                <example>det-sing-masc</example>
                <example correction=""><marker>det-sing-masc adj-sing-masc subst-plur-fem</marker></example>
                <example correction=""><marker>det-sing-fem adj-sing-masc subst-plur-fem</marker></example>
                <example correction=""><marker>det-sing-fem adj-sing-fem subst-plur-fem</marker></example>
                <example correction=""><marker>det-plur-fem adj-sing-fem subst-plur-fem</marker></example>
            </rule>
        </rulegroup>
        <rulegroup id="suggestions_outside_message" name="Test suggestions written outside message">
            <rule>
                <pattern>
                    <marker>
                        <token>blah</token>
                        <token>and</token>
                    </marker>
                    <token>blah</token>
                </pattern>
                <message>Incorrect expression</message>
                <suggestion>blah or</suggestion>
                <suggestion>blah xor</suggestion>
                <example correction="blah or|blah xor"><marker>blah and</marker> blah</example>
                <example>blah or blah</example>
            </rule>
            <rule>
                <pattern>
                    <marker>
                        <token>blah</token>
                        <token>and</token>
                    </marker>
                    <token>blah</token>
                </pattern>
                <message>Incorrect expression: <suggestion>blah or</suggestion></message>
                <suggestion>blah xor</suggestion>
                <example correction="blah or|blah xor"><marker>blah and</marker> blah</example>
                <example>blah or blah</example>
            </rule>
            <rule>
                <pattern>
                    <marker>
                        <token>blah</token>
                        <token>and</token>
                    </marker>
                    <token>blah</token>
                </pattern>
                <message>Incorrect expression: <suggestion><match no="1"/> or</suggestion></message>
                <suggestion>blah <match no="1"/></suggestion>
                <example correction="blah or|blah blah"><marker>blah and</marker> blah</example>
                <example>blah or blah</example>
            </rule>
        </rulegroup>
    </category>
    <category id="MINMAX" name="Test tokens with min and max attributes">
        <rule id="TEST_MIN_OCCURRENCE" name="Test whether minOccurrence is handled correctly">
            <pattern>
                <token min="2">blah</token>
            </pattern>
            <message>Incorrect expression. Whatever</message>
            <example>Blah?</example>
            <example correction=""><marker>Blah blah</marker> foo.</example>
        </rule>
        <rule id="TEST_MAX_OCCURRENCE" name="Test whether maxOccurrence is handled correctly">
            <pattern>
                <token max="2">blah</token>
            </pattern>
            <message>Incorrect expression. Whatever</message>
            <example>lah?</example>
            <!-- cannot test this, as we get two rule matches here:
                <example correction=""><marker>Blah blah</marker> foo.</example>
            -->
            <example correction=""><marker>blah</marker></example>
        </rule>
        <rule id="TEST_MIN_MAX_OCCURRENCE" name="Test whether minOccurrence is handled correctly">
            <pattern>
                <token>a</token>
                <token min="2" max="3">b</token>
                <token>c</token>
            </pattern>
            <message>Incorrect expression. Whatever</message>
            <example>a b c</example>
            <example>a c</example>
            <example correction=""><marker>a B b B c</marker></example>
            <example correction=""><marker>a b b b c</marker></example>
            <example correction=""><marker>a b b c</marker></example>
        </rule>
        <rulegroup id="TEST_MIN_MAX_OCCURRENCE_WITH_AND" name="Test whether minOccurrence is handled correctly in AND clauses">
           <rule>
            <pattern>
                <token>a</token>
                <and>
                <token min="2" max="3">b</token>
                <token regexp="yes">(?iu)\p{Ll}</token>
                </and>
                <token>c</token>
            </pattern>
            <message>Incorrect expression. Whatever</message>
            <example>a b c</example>
            <example>a c</example>
            <!-- 'B' is uppercase, so the condition 2 in AND should exclude it -->
            <example><marker>a B b b c</marker></example>
            <example correction=""><marker>a b b b c</marker></example>
            <example correction=""><marker>a b b b c</marker></example>
            <example correction=""><marker>a b b c</marker></example>
            </rule>
            <!-- this rule would cause SAXException
            <rule>
                <pattern>
                    <token>a</token>
                    <and>
                        NOTE: now the min/max token is the second one -
                        and this causes the exception to be thrown!
                        <token regexp="yes">(?iu)\p{Ll}</token>
                        <token min="2" max="3">b</token>
                    </and>
                    <token>c</token>
                </pattern>
                <message>Incorrect expression. Whatever</message>
                <example>a b c</example>
                <example>a c</example>
                <example><marker>a B b b c</marker></example>
                <example correction=""><marker>a b b b c</marker></example>
                <example correction=""><marker>a b b b c</marker></example>
                <example correction=""><marker>a b b c</marker></example>
            </rule>
            -->
        </rulegroup>
        <rulegroup id="test_min_max_unification" name="Test unification of character case with min/max">
            <rule>
            <pattern case_sensitive="yes">
                <token>abc</token>
                <marker>
                    <unify> <feature id="case_sensitivity">
                        <type id="startupper"/>
                    </feature>
                        <token max="3"/>
                        <token>York</token>
                    </unify>
                </marker>
            </pattern>
            <message>Warning: \1 \2 \3!</message>
            <example correction="">abc <marker>New York</marker></example>
            <example correction="">abc <marker>Really New York</marker></example>
            <example correction="">abc <marker>Absolutely Really New York</marker></example>
            <example>abc new York</example>
        </rule>
            <rule>
                <pattern case_sensitive="yes">
                    <token>abc</token>
                    <marker>
                        <unify> <feature id="case_sensitivity">
                            <type id="startupper"/>
                        </feature>
                            <token min="2" max="3"/>
                            <token>York</token>
                        </unify>
                    </marker>
                </pattern>
                <message>Warning: \1 \2 \3!</message>
                <example>abc <marker>New York</marker></example>
                <example correction="">abc <marker>Really New York</marker></example>
                <example correction="">abc <marker>Absolutely Really New York</marker></example>
                <example>abc new York</example>
            </rule>
        </rulegroup>
        <rule id="test_OR_with_min_max" name="Test OR with token min/max">
            <pattern>
                <or>
                    <token max="2">abc</token>
                    <token max="3">dfg</token>
                </or>
                    <token>test</token>
            </pattern>
            <message>.</message>
            <example>dfg abc</example>
            <example>abc dfg</example>
            <example correction=""><marker>abc test</marker></example>
            <example correction=""><marker>dfg test</marker></example>
            <example correction=""><marker>abc abc test</marker></example>
            <example correction=""><marker>dfg dfg test</marker></example>
            <example correction=""><marker>dfg dfg dfg test</marker></example>
        </rule>

        <rule id="test_partialPosTagFilter" name="Test for PartialPosTagFilter">
            <pattern>
                <token regexp="yes">(in|un).*</token>
            </pattern>
            <filter class="org.languagetool.rules.DemoPartialPosTagFilter" args="no:1 regexp:(?:in|un)(.*) postag_regexp:JJ"/>
            <message>Approved adjective, but not-approved prefix. Use 'not' + adjective</message>
            <example correction="">That's <marker>inaccurate</marker>.</example>
            <example>That's <marker>not accurate</marker>.</example>
            <example>That's <marker>insomething</marker>.</example>
        </rule>
        <rule id="test_partialPosTagFilter_with_regex" name="Test for PartialPosTagFilter">
            <pattern>
                <token regexp="yes">(in|un).*</token>
            </pattern>
            <filter class="org.languagetool.rules.DemoPartialPosTagFilter" args="no:1 regexp:(?:in|un)(.*) postag_regexp:J[XJ]"/>
            <message>Approved adjective, but not-approved prefix. Use 'not' + adjective</message>
            <example correction="">That's <marker>inaccurate</marker>.</example>
            <example>That's <marker>not accurate</marker>.</example>
            <example>That's <marker>insomething</marker>.</example>
        </rule>

        <!-- FIXME: not sure how to deal with \1 referring to <token max="2"/> ... probably
        there might be different uses here, with a space or without it... right now
        we simply match only the first token, and match include_skipped="yes" does not
        work for it
        <rule id="test_max_suggestion_matches" name="Test reference to a token with max attribute">
            <pattern>
                <token max="2">abc</token>
                <token>dfg</token>
            </pattern>
            <message>Whatever</message>
            <suggestion>\1\2</suggestion>
            <example>abcdfg</example>
            <example correction="abcdfg">Test <marker>abc dfg</marker>.</example>
            <example correction="abcabcdfg">Test <marker>abc abc dfg</marker>.</example>
        </rule>
        -->
    </category>

    <category id="RAW_POS_CAT" name="Tests for raw_pos" default="off">
        <rule id="RAW_POS1" name="Rule 1 - no raw_pos">
            <pattern>
                <token postag="CD"/>
            </pattern>
            <message>bla</message>
            <example correction=""><marker>5</marker></example>
        </rule>
        <rule id="RAW_POS2" name="Rule 2 - raw_pos">
            <pattern raw_pos="yes">
                <token postag="UNKNOWN"/>
            </pattern>
            <message>bla</message>
            <example correction=""><marker>5</marker></example>
        </rule>
    </category>
    
    <category id="DEFAULT_OFF" name="A category that's off by default" default="off">
        <rule id="IN_OFF_CATEGORY" name="Rule 1">
            <pattern>
                <token>foobar</token>
            </pattern>
            <message>bla</message>
            <example correction="">Some <marker>foobar</marker></example>
        </rule>
        <rule id="IN_OFF_CATEGORY_OFF_ITSELF" name="Rule 2" default="off">
            <pattern>
                <token>foobar</token>
            </pattern>
            <message>bla</message>
            <example correction="">Some <marker>foobar</marker></example>
        </rule>
    </category>

</rules>
